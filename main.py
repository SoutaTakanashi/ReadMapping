from Bio import SeqIO
import time
start = time.time()


def extractSeq(name,type):
    seqs = [str(fa.seq) for fa in SeqIO.parse(name,type)]
    return seqs
seqList1=extractSeq("10k_reads.fastq", "fastq")

def mergeSeq(fileName):#Get a full length sequence instead of in rows.
    res=''
    with open(fileName) as fasta:
        next(fasta)
        for line in fasta:
            line = line.rstrip()  # Remove the '\t' on the right of each line
            res += ('' + str(line).upper())
    return res
chr_genome = mergeSeq("chr2L.fa") + '$'  # genome is full chr2L seq

def getSufList(genome):
    temp = []
    for i in range(len(genome) - 1):
        if i + 36 > len(genome) - 1:
            temp.append(((i + 1), genome[i:]))
        else:
            #We cannot get all the suffix from length 1 to full length
            # (Therefore maxi len = 36, 36 is the length of a row in 10k_fasta)
            temp.append(((i + 1), genome[i:i + 36]))

    def ruleSuf(temp_Tuple):
        #Rule of sorting
        i, suffix = temp_Tuple # (order,suffix)
        return suffix  # To sort the suffix in the Two-tuple generated by last step
    sufList = sorted(temp, key=ruleSuf)
    return sufList
sufList=getSufList(chr_genome)

def minDistance(word1, word2):# The distance(similarity) of the read and genome sequence.
    if not word1:
        return len(word2 or '') or 0

    if not word2:
        return len(word1 or '') or 0

    size1 = len(word1)
    size2 = len(word2)

    last = 0
    tmp = list(range(size2 + 1))
    value = None

    for i in range(size1):
        tmp[0] = i + 1
        last = i

        for j in range(size2):
            if word1[i] == word2[j]:
                value = last
            else:
                value = 1 + min(last, tmp[j], tmp[j + 1])

            last = tmp[j+1]
            tmp[j+1] = value

    return value

matchRes = []
def match(read,suffix_arr,tolerance): #Tolerance: the greatest difference acceptable that the read is different from the genome suffix

    def compareStr(read,genSuffix):
        if read==genSuffix:
            return 0
        elif read<genSuffix:
            return -1
        else:
            return 1
    def binarySearch(tolerance):# Use binary search to reduce time complexity
        temp = []
        res = []
        left = 0
        right = len(suffix_arr) - 1
        # Mark the range of searching for imin and imax in suffix array
        threshold=[0,0]
        bestPos = 0
        success = False
        while left <= right and success==False:
            mid = left + ((right - left) >> 1) #i.e. mid = (left + right)//2
            curr = suffix_arr[mid][1]
            flag = compareStr(read, curr)
            threshold[0]=left
            threshold[1]=right
            bestPos = mid
            if flag == 0:
                success = True
            elif flag == 1:
                left = mid + 1
            else:
                right = mid - 1
        #print(bestPos)
        if success ==False:
            if minDistance(read,suffix_arr[bestPos][1])<=tolerance:
                success=True
            else: return res

        for i in range(0,2^12):# Find in a threshold to get i_min and i_max
            if minDistance(read,suffix_arr[i+bestPos][1])<=tolerance and i+bestPos<len(suffix_arr):
                temp.append(i+bestPos)
            if minDistance(read,suffix_arr[bestPos-i][1])<=tolerance and bestPos-i>=0:
                temp.append(bestPos-i)

        if len(temp)>1: #Get i_min and i_max
            res.append(min(temp))
            res.append(max(temp))
        return res
    result=binarySearch(tolerance)

    return result
count=0
total=0
same=0
for read in seqList1:
    res = match(read,sufList,4)#We assume it is acceptable if the read and genome suffix has 6 character different.
    #print(res)
    total+=1
    if len(res)>1:
        i_min =res[0]
        i_max =res[-1]
        matchRes.append((sufList[i_min][0],
        sufList[i_min][1],sufList[i_max][0],
        sufList[i_max][1]))
        count+=1
        if i_min==i_max:
            same+=1
    else:
        continue
print(matchRes)
print(f"percentage of mapped reads:{100*count/total }%")
print(f"percentage of mapped reads have different i_min and i_max:{100*(count-same)/count }%")
end = time.time()
print (f"Time used:{end-start} seconds")
